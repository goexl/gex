# 介绍

Gex是一个方便开发者调用外部程序的扩展库，可以很方便的调用任何外部程序，且提供了如下功能

- 最简单的`API`封装
- 非常好的扩展性
- 检查器
- 收集器
- 通知器
- 管道

## 它是如何工作的

得益于Golang良好的封装性，将所有不需要用户参与的代码都封闭在了框架内部且对用户不可见，对外只暴露了`Start`方法。
如果开发者想对执行过程做配置，可以调用相关配置选项即可

## 功能特性

**简单的API封装**

如果不需要对执行过程有要求，只需要调用`Start`方法即可完成

**丰富的配置选项**

- 参数
- 运行时目录
- 环境变量
- 异步/同步
- 静默模式
- 控制台输出

**检查器**

检查器是用于方便命令执行期间，当检查器检查成功后，可以立即返回而不用等到命令执行完成才继续往下执行。 典型的应用场景是

> 当需要调用的外部命令是一个服务（需要长期运行，甚至于要一直运行），但是又不能让程序一直等待服务执行完毕且也不能调用命令后就继续执行（需要等待服务正确完成启动后才能使用服务），此时就可以使用检查器来完成这个操作

内置的检查器有

- 字符串包含`Contains`
- 字符串全包含`ContainsAll`
- 字符串任何包含`ContainsAny`
- 字符串相等`Equal`
- 路径模式匹配`PathMatch`
- 正则匹配`Regexp`

**收集器**

收集器的目的在于，在命令执行时，将结果收集出起来，当命令执行完成后

- 结果分析
- 进度显示

典型的场景是
> 比如外部调用`ffmpeg`，执行过程中，输出转码进度

内置收集器有

- 字符串`String`
- 写入者`Writer`

**通知器**

通知器是在命令执行过程中，在合适的时机通知调用方式

- 执行成功时
- 执行遇到错误时

## 设计原则

力求保持简单是`Gex`在代码设计中最大的原则，此外还有

- 语义化（比如`Name`可以配置的项有：`应用程序`名称、`添加依赖`时的名称以及`获取依赖`时的名称）
- 尽量不暴露内部实现
- 线程安全
